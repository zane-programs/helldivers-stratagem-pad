<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>

  <link rel="stylesheet" href="./style.css" />
</head>

<body>
  <div class="loading-screen" id="loadingScreen">
    <div class="loading-spinner"></div>
    <div class="loading-text">Loading Stratagems...</div>
  </div>

  <div class="input-display" id="inputDisplay"></div>

  <div class="stratagem-display" id="stratagemDisplay">
    <img class="stratagem-icon" id="stratagemIcon" src="" alt="" />
    <div class="request-received">REQUEST RECEIVED:</div>
    <div class="stratagem-name" id="stratagemName"></div>
  </div>  <div class="stratagem-display" id="stratagemDisplay">
    <img class="stratagem-icon" id="stratagemIcon" src="" alt="" />
    <div class="stratagem-name" id="stratagemName"></div>
  </div>

  <div class="arrows">
    <button class="arrow-up">
      <img draggable="false" src="./img/uphd2.svg" alt="Up Arrow" />
    </button>
    <button class="arrow-left">
      <img draggable="false" src="./img/lefthd2.svg" alt="Left Arrow" />
    </button>
    <button class="arrow-right">
      <img draggable="false" src="./img/righthd2.svg" alt="Right Arrow" />
    </button>
    <button class="arrow-down">
      <img draggable="false" src="./img/downhd2.svg" alt="Down Arrow" />
    </button>
  </div>
  <button class="ctrl-button" id="ctrlButton">
    <img draggable="false" src="./img/Apple Keyboard Control Icon.svg" alt="Down Arrow" />
  </button>
  <script>
    (function () {
      const ARROW_MAPPINGS = {
        up: "w",
        down: "s",
        left: "a",
        right: "d",
      };

      let stratagems = [];
      let currentInput = [];
      let ctrlActive = false;
      let isDisplayingStratagem = false;
      let ws = null;
      let serverConnected = false;

      const ctrlButton = document.getElementById("ctrlButton");
      const arrowButtons = document.querySelectorAll(".arrows button");
      const loadingScreen = document.getElementById("loadingScreen");
      const inputDisplay = document.getElementById("inputDisplay");
      const stratagemDisplay = document.getElementById("stratagemDisplay");
      const stratagemIcon = document.getElementById("stratagemIcon");
      const stratagemName = document.getElementById("stratagemName");

      // WebSocket connection
      function connectWebSocket() {
        try {
          ws = new WebSocket(`ws://${window.location.host}`);

          ws.onopen = () => {
            console.log('[Client] Connected to server');
            serverConnected = true;
            // Connect to HID device
            sendMessage({ type: 'connect' });
          };

          ws.onmessage = (event) => {
            try {
              const message = JSON.parse(event.data);
              handleServerMessage(message);
            } catch (error) {
              console.error('[Client] Error parsing message:', error);
            }
          };

          ws.onclose = () => {
            console.log('[Client] Disconnected from server');
            serverConnected = false;
            // Attempt to reconnect after 2 seconds
            setTimeout(connectWebSocket, 2000);
          };

          ws.onerror = (error) => {
            console.error('[Client] WebSocket error:', error);
            serverConnected = false;
          };
        } catch (error) {
          console.error('[Client] Failed to connect:', error);
          setTimeout(connectWebSocket, 2000);
        }
      }

      function sendMessage(message) {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify(message));
        }
      }

      function handleServerMessage(message) {
        switch (message.type) {
          case 'connected':
            console.log('[Client] HID device connected');
            break;
          case 'error':
            console.error('[Client] Server error:', message.message);
            break;
          default:
            console.log('[Client] Received:', message);
        }
      }

      async function loadStratagems() {
        try {
          const response = await fetch("./stratagems.json");
          if (!response.ok) {
            throw new Error("Failed to load stratagems");
          }
          stratagems = await response.json();
          console.log(`Loaded ${stratagems.length} stratagems`);
          hideLoadingScreen();
        } catch (error) {
          console.error("Error loading stratagems:", error);
          loadingScreen.querySelector(".loading-text").textContent =
            "Error loading stratagems";
        }
      }

      function hideLoadingScreen() {
        loadingScreen.classList.add("hidden");
        setTimeout(() => {
          loadingScreen.style.display = "none";
        }, 300);
      }

      function updateArrowButtons() {
        arrowButtons.forEach((button) => {
          if (!isDisplayingStratagem) {
            button.classList.remove("disabled");
          } else {
            button.classList.add("disabled");
          }
        });
      }

      function updateInputDisplay() {
        if (currentInput.length > 0) {
          inputDisplay.textContent = currentInput.join(" â†’ ");
          inputDisplay.classList.add("active");
        } else {
          inputDisplay.classList.remove("active");
        }
      }

      function checkForStratagem() {
        for (const stratagem of stratagems) {
          if (arraysEqual(currentInput, stratagem.inputCode) && ctrlActive) {
            displayStratagem(stratagem);
            return true;
          }
        }
        return false;
      }

      function arraysEqual(a, b) {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) return false;
        }
        return true;
      }

      function displayStratagem(stratagem) {
        isDisplayingStratagem = true;

        stratagemIcon.src = `./img/Helldivers-2-Stratagems-icons-svg/${stratagem.icon}`;
        stratagemIcon.alt = stratagem.name;
        stratagemName.textContent = stratagem.name;
        stratagemDisplay.style.borderColor = stratagem.color;
        stratagemDisplay.classList.add("active");

        updateArrowButtons();

        setTimeout(() => {
          resetStratagem();
        }, 2000);
      }

      function resetStratagem() {
        // Release Ctrl key on server
        if (serverConnected) {
          sendMessage({ type: 'releaseAll' });
        }

        ctrlActive = false;
        ctrlButton.classList.remove("active");
        currentInput = [];
        isDisplayingStratagem = false;

        stratagemDisplay.classList.remove("active");
        inputDisplay.classList.remove("active");

        updateArrowButtons();
      }

      function handleArrowClick(direction) {
        if (isDisplayingStratagem || !serverConnected) return;

        const key = ARROW_MAPPINGS[direction];
        
        if (ctrlActive) {
          // Track input for stratagem matching when CTRL is held
          currentInput.push(key.toUpperCase());
          
          // Send key press while CTRL is being held
          sendMessage({
            type: 'pressWithHeld',
            key: key,
            options: {
              holdTime: 50,
              autoRelease: true
            }
          });
          
          updateInputDisplay();

          if (!checkForStratagem()) {
            const maxLength = Math.max(
              ...stratagems.map((s) => s.inputCode.length)
            );
            if (currentInput.length >= maxLength) {
              currentInput = [];
              updateInputDisplay();
            }
          }
        } else {
          // Send regular key press when CTRL is not held
          sendMessage({
            type: 'pressKey',
            key: key,
            options: {
              holdTime: 50,
              autoRelease: true
            }
          });
        }
      }

      ctrlButton.addEventListener("click", () => {
        if (isDisplayingStratagem || !serverConnected) return;

        ctrlActive = !ctrlActive;
        ctrlButton.classList.toggle("active", ctrlActive);

        if (ctrlActive) {
          // Hold the CTRL key when activated
          sendMessage({
            type: 'holdKey',
            key: 'ctrl'
          });
        } else {
          // Release all keys and clear input when deactivated
          sendMessage({ type: 'releaseAll' });
          currentInput = [];
          updateInputDisplay();
        }

        updateArrowButtons();
      });

      arrowButtons.forEach((button) => {
        button.addEventListener("click", () => {
          if (!isDisplayingStratagem) {
            const direction = button.className
              .replace("arrow-", "")
              .replace(" disabled", "");
            handleArrowClick(direction);
          }
        });
      });

      // Initialize application
      loadStratagems();
      updateArrowButtons();
      connectWebSocket();
    })();
  </script>
</body>

</html>